import asyncio
import json
import re
import time
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, TypedDict

from langgraph.graph import StateGraph, END
from playwright.async_api import async_playwright
from lxml import html as lxml_html

from brain import LLMVLMBasedBrain
from model_stack import get_model_name_for_path, load_model_stack

from tools import (
    TraceLogger,
    tool_click,
    tool_dom_snapshot,
    tool_fill,
    tool_goto,
    tool_screenshot,
    tool_set_range,
    tool_select,
    tool_wait_for_any,
    tool_wait_for_not_loading,
    tool_wait_for_url_change,
    tool_check,
)

TARGET = "http://localhost:3000/survey"
SURVEY_VERSION = "survey_v0"
MAX_EMPTY_PLAN_STREAK = 5
MAX_PLAN_RETRIES = 2
MAX_FEEDBACK_MEMORY = 3
# Toggle DOM HTML artifact saving for debugging.
# Screenshots and trace logs remain enabled regardless.
SAVE_DOM_HTML_ARTIFACTS = False
# SAVE_DOM_HTML_ARTIFACTS = True
# Toggle live progress heartbeat in console + trace.
# ENABLE_LIVE_PROGRESS = True
ENABLE_LIVE_PROGRESS = False


class AgentState(TypedDict, total=False):
    url: str
    dom_path: str
    screenshot_path: str
    parsed: Dict[str, Any]
    action_space: Dict[str, Any]
    action_space_path: str
    plan: List[Dict[str, Any]]
    plan_feedback: List[str]
    step_idx: int
    max_steps: int
    empty_plan_streak: int
    last_exec_ts: float
    done: bool
    error: str


@dataclass
class RunCtx:
    page: Any
    logger: TraceLogger
    out_dir: Path
    brain: Any


def _emit_progress(
    ctx: "RunCtx",
    phase: str,
    state: AgentState,
    extra: Dict[str, Any] | None = None,
):
    if not ENABLE_LIVE_PROGRESS:
        return
    payload: Dict[str, Any] = {
        "phase": phase,
        "url": str(state.get("url") or ctx.page.url),
        "step_idx": int(state.get("step_idx", 0)),
    }
    last_exec_ts = state.get("last_exec_ts")
    if isinstance(last_exec_ts, (int, float)):
        payload["seconds_since_last_exec"] = round(max(0.0, time.monotonic() - float(last_exec_ts)), 2)
    if extra:
        payload.update(extra)
    ctx.logger.log("progress", payload)
    idle_text = ""
    if "seconds_since_last_exec" in payload:
        idle_text = f" idle={payload['seconds_since_last_exec']}s"
    print(
        f"[progress] phase={payload['phase']} step={payload['step_idx']} url={payload['url']}{idle_text}",
        flush=True,
    )


def parse_survey_dom(dom_html: str) -> Dict[str, Any]:
    """
    Extract generic form schema for LLM planning:
    - available selectors for fill/select/click
    - field metadata (type/label/options)
    - shape targets for visual attention checks
    """
    tree = lxml_html.fromstring(dom_html)
    root_tree = tree.getroottree()

    def selector_for(el) -> str | None:
        element_id = el.get("id")
        if element_id:
            return f"#{element_id}"

        name = el.get("name")
        if name:
            return f'{el.tag}[name="{name}"]'

        data_testid = el.get("data-testid")
        if data_testid:
            return f'{el.tag}[data-testid="{data_testid}"]'

        if el.tag == "button":
            text = " ".join(el.itertext()).strip()
            if text:
                safe_text = text.replace('"', '\\"')
                return f'button:has-text("{safe_text}")'
            return "button"

        # Fallback for unlabeled controls generated by React.
        return f"xpath={root_tree.getpath(el)}"

    def selector_for_any(el) -> str:
        element_id = el.get("id")
        if element_id:
            return f"#{element_id}"
        data_testid = el.get("data-testid")
        if data_testid:
            return f'{el.tag}[data-testid="{data_testid}"]'
        aria_label = el.get("aria-label")
        if aria_label:
            safe_label = aria_label.replace('"', '\\"')
            return f'{el.tag}[aria-label="{safe_label}"]'
        return f"xpath={root_tree.getpath(el)}"

    def question_meta_for(el) -> Dict[str, str]:
        node = el
        best = {"id": "", "label": "", "type": ""}
        while node is not None:
            qid = node.get("data-question-id")
            qlabel = node.get("data-question-label")
            qtype = node.get("data-question-type")
            if qid and not best["id"]:
                best["id"] = qid.strip()
            if qlabel:
                best["label"] = qlabel.strip()
            if qtype:
                best["type"] = qtype.strip()
            # Do not stop at nodes that only carry data-question-id (e.g. option labels).
            # Keep climbing to capture the container-level question label/type.
            if best["label"] or best["type"]:
                break
            node = node.getparent()
        return best

    def legend_for(el) -> str:
        try:
            fieldset_anc = el.xpath("ancestor::fieldset[1]")
            if fieldset_anc:
                legends = fieldset_anc[0].cssselect("legend")
                for legend in legends:
                    text = " ".join(legend.itertext()).strip()
                    if text:
                        return text
        except Exception:
            pass
        return ""

    def label_for(el) -> str:
        element_id = el.get("id")
        if element_id:
            candidates = tree.cssselect(f'label[for="{element_id}"]')
            for cand in candidates:
                text = " ".join(cand.itertext()).strip()
                if text:
                    return text
                imgs = cand.cssselect("img")
                if imgs:
                    alt = (imgs[0].get("alt") or "").strip()
                    if alt:
                        return alt

        parent = el.getparent()
        if parent is not None and parent.tag == "label":
            text = " ".join(parent.itertext()).strip()
            if text:
                return text
            imgs = parent.cssselect("img")
            if imgs:
                alt = (imgs[0].get("alt") or "").strip()
                if alt:
                    return alt

        legend_text = legend_for(el)
        if legend_text:
            return legend_text

        qmeta = question_meta_for(el)
        if qmeta.get("label"):
            return qmeta["label"]

        return ""

    schema = {
        "selectors": {},
        "fields": [],
        "shapes": [],
        "captcha": None,
    }

    field_index = 0
    grouped_radios: Dict[str, Dict[str, Any]] = {}
    radios = tree.cssselect('input[type="radio"]')
    radios_by_name: Dict[str, List[Any]] = {}
    for radio in radios:
        radio_name = radio.get("name")
        if radio_name:
            radios_by_name.setdefault(radio_name, []).append(radio)

    for name, group in radios_by_name.items():
        group_selector = f'input[type="radio"][name="{name}"]'
        group_required = any(r.get("required") is not None for r in group)
        group_meta = question_meta_for(group[0])
        group_label = group_meta.get("label") or label_for(group[0])
        grouped_radios[name] = {
            "key": group_meta.get("id") or name,
            "selector": group_selector,
            "tag": "input",
            "type": "radio",
            "label": group_label,
            "question_text": group_label,
            "required": group_required,
            "interaction": "check",
            "options": [],
        }
        schema["selectors"][grouped_radios[name]["key"]] = group_selector

        for idx, el in enumerate(group):
            element_id = el.get("id")
            option_selector = f'input[type="radio"][name="{name}"] >> nth={idx}'
            option_alt = ""
            if element_id:
                label_candidates = tree.cssselect(f'label[for="{element_id}"]')
                if label_candidates:
                    option_selector = f'label[for="{element_id}"]'
                    imgs = label_candidates[0].cssselect("img")
                    if imgs:
                        option_alt = (imgs[0].get("alt") or "").strip()
                else:
                    option_selector = f"#{element_id}"

            grouped_radios[name]["options"].append(
                {
                    "id": element_id,
                    "value": el.get("value") or "on",
                    "label": label_for(el),
                    "alt": option_alt,
                    "question_text": group_label,
                    "selector": option_selector,
                }
            )
            field_index += 1

    schema["fields"].extend(grouped_radios.values())

    for el in tree.cssselect("input, textarea, select, button"):
        if el.tag == "input" and (el.get("type") or "").lower() in {"radio"}:
            continue

        selector = selector_for(el)
        if not selector:
            continue

        qmeta = question_meta_for(el)
        key = qmeta.get("id") or el.get("id") or el.get("name") or f"field_{field_index}"
        field_index += 1
        schema["selectors"][key] = selector

        interaction = "fill"
        input_type = (el.get("type") or "").lower() if el.tag == "input" else ""
        if el.tag == "input" and input_type == "range":
            interaction = "set_range"
        elif el.tag == "input" and input_type == "checkbox":
            interaction = "check"
        if el.tag == "select":
            interaction = "select"
        elif el.tag == "button":
            interaction = "click"

        field = {
            "key": key,
            "selector": selector,
            "tag": el.tag,
            "type": el.get("type") if el.tag == "input" else None,
            "inputType": el.get("type") if el.tag == "input" else None,
            "name": el.get("name"),
            "id": el.get("id"),
            "required": bool(el.get("required") is not None),
            "label": qmeta.get("label") or label_for(el),
            "question_text": qmeta.get("label") or "",
            "placeholder": el.get("placeholder"),
            "text": " ".join(el.itertext()).strip() if el.tag == "button" else "",
            "interaction": interaction,
        }

        if el.tag == "select":
            field["options"] = [
                {
                    "value": opt.get("value", ""),
                    "label": " ".join(opt.itertext()).strip(),
                }
                for opt in el.cssselect("option")
            ]

        if interaction == "set_range":
            min_v = float(el.get("min") or 0)
            max_v = float(el.get("max") or 100)
            step_v = float(el.get("step") or 1)
            default_v = float(el.get("value") or min_v)
            field["min"] = min_v
            field["max"] = max_v
            field["step"] = step_v
            field["default"] = default_v

        if el.tag == "input" and input_type == "number":
            field["min"] = float(el.get("min")) if el.get("min") is not None else None
            field["max"] = float(el.get("max")) if el.get("max") is not None else None
            field["step"] = float(el.get("step")) if el.get("step") is not None else None

        if interaction == "check" and (el.get("type") or "").lower() == "checkbox":
            checkbox_value = el.get("value") or "on"
            checkbox_id = el.get("id")
            option_selector = f"#{checkbox_id}" if checkbox_id else selector
            field["options"] = [
                {
                    "id": checkbox_id,
                    "value": checkbox_value,
                    "label": label_for(el),
                    "selector": option_selector,
                }
            ]

        schema["fields"].append(field)
        if el.tag == "button":
            button_text = " ".join(el.itertext()).strip().lower()
            if "next" in button_text:
                schema["selectors"]["next"] = selector if selector != "button" else 'button:has-text("Next")'
            if "submit" in button_text:
                schema["selectors"]["submit"] = selector

    def question_text_for(el) -> str:
        prev_nodes = el.xpath(
            "preceding::*[(self::h1 or self::h2 or self::h3 or self::label or self::div) and normalize-space()]"
        )
        for node in reversed(prev_nodes):
            text = " ".join(node.itertext()).strip()
            if not text:
                continue
            lowered = text.lower()
            if re.match(r"^\d+\)", text) or "which image" in lowered or "select the" in lowered:
                return text
        if prev_nodes:
            return " ".join(prev_nodes[-1].itertext()).strip()
        return ""

    has_structured_image_checks = any(
        isinstance(name, str) and (name.startswith("image_") or name.startswith("attention_image"))
        for name in radios_by_name.keys()
    )

    # Parse likely image answer options on /survey/image only when structured radio groups are absent.
    if not has_structured_image_checks:
        image_option_idx = 0
        for el in tree.cssselect("div, figure, a, button, label, img, [role='button'], div[role], div[onclick]"):
            img = el if el.tag == "img" else (el.cssselect("img")[0] if el.cssselect("img") else None)
            if img is None:
                continue

            style_text = (el.get("style") or "").lower()
            has_pointer = "cursor: pointer" in style_text or "cursor:pointer" in style_text
            has_hint_attr = bool(el.get("data-testid") or el.get("aria-label") or el.get("id"))
            if not (has_pointer or has_hint_attr or el.tag == "img"):
                continue

            clickable = el if el.tag != "img" else (el.getparent() if el.getparent() is not None else el)
            selector = selector_for_any(clickable)
            key = f"image_option_{image_option_idx}"
            image_option_idx += 1

            src = img.get("src")
            alt = img.get("alt") or ""
            qtext = question_text_for(clickable)

            field = {
                "key": key,
                "selector": selector,
                "tag": clickable.tag,
                "interaction": "click",
                "kind": "image_option",
                "question_text": qtext,
                "alt": alt,
                "src": src,
                "name": clickable.get("name"),
                "id": clickable.get("id"),
                "required": False,
            }
            schema["fields"].append(field)
            schema["selectors"][key] = selector

    # Detect captcha code text near captcha input.
    captcha_inputs = tree.xpath(
        "//input[contains(translate(@placeholder,'ABCDEFGHIJKLMNOPQRSTUVWXYZ','abcdefghijklmnopqrstuvwxyz'),'code') "
        "or contains(translate(@aria-label,'ABCDEFGHIJKLMNOPQRSTUVWXYZ','abcdefghijklmnopqrstuvwxyz'),'code')]"
    )
    if captcha_inputs:
        cap_input = captcha_inputs[0]
        input_selector = selector_for_any(cap_input)
        strict_token = re.compile(r"^[A-Z0-9]{4,8}$")
        fallback_token = re.compile(r"\b[A-Z0-9]{4,8}\b")
        blocked_tokens = {"THIS", "TYPE", "CODE", "CAPTCHA", "SHOWN", "EXACTLY"}

        def extract_strict_token(text: str) -> str | None:
            normalized = re.sub(r"\s+", "", text).upper()
            if strict_token.fullmatch(normalized) and normalized not in blocked_tokens:
                return normalized
            return None

        def extract_fallback_token(text: str) -> str | None:
            for token in fallback_token.findall(text.upper()):
                if token in blocked_tokens:
                    continue
                if not any(ch.isalpha() for ch in token):
                    continue
                if not any(ch.isdigit() for ch in token):
                    continue
                return token
            return None

        code_text = None
        # Prefer text in the same captcha block before scanning broader context.
        local_nodes = cap_input.xpath("preceding-sibling::*[(self::div or self::span or self::p) and normalize-space()]")
        for node in reversed(local_nodes):
            text = " ".join(node.itertext()).strip()
            token = extract_strict_token(text)
            if token:
                code_text = token
                break
        if not code_text:
            nearby = cap_input.xpath("preceding::*[(self::div or self::span or self::p) and normalize-space()]")
            for node in reversed(nearby[-30:]):
                text = " ".join(node.itertext()).strip()
                token = extract_fallback_token(text)
                if token:
                    code_text = token
                    break
        if code_text:
            schema["captcha"] = {"code_text": code_text, "input_selector": input_selector}
            schema["selectors"]["captcha_input"] = input_selector

    # Shapes have data-shape-id and data-shape-kind
    for el in tree.cssselect("[data-shape-id][data-shape-kind]"):
        schema["shapes"].append(
            {
                "id": el.get("data-shape-id"),
                "kind": el.get("data-shape-kind"),
                # We can later add bbox extraction via Playwright if needed
            }
        )

    return schema


def build_action_space(schema: Dict[str, Any]) -> Dict[str, Any]:
    """
    Build the validator-first action gate from parsed DOM schema.
    This is the per-page valid action set given to the planner.
    """
    action_fields: List[Dict[str, Any]] = []
    seen_keys = set()
    source_fields = schema.get("fields") or []
    captcha_info = schema.get("captcha") if isinstance(schema.get("captcha"), dict) else None
    captcha_input_selector = ""
    captcha_code_text = ""
    if captcha_info:
        captcha_input_selector = str(captcha_info.get("input_selector") or "")
        captcha_code_text = str(captcha_info.get("code_text") or "")

    for f in source_fields:
        if not isinstance(f, dict):
            continue
        key = f.get("key")
        interaction = f.get("interaction")
        selector = f.get("selector")
        if (
            not isinstance(key, str)
            or not key
            or not isinstance(interaction, str)
            or interaction not in {"fill", "select", "check", "set_range", "click"}
            or not isinstance(selector, str)
            or not selector
        ):
            continue
        if key in seen_keys:
            continue
        seen_keys.add(key)

        action_field: Dict[str, Any] = {
            "key": key,
            "interaction": interaction,
            "selector": selector,
            "label": f.get("label") or "",
            "required": bool(f.get("required") is True),
        }
        if interaction == "check":
            action_field["label"] = "check"
        action_field["tool_hint"] = interaction

        if f.get("kind"):
            action_field["kind"] = f.get("kind")
        if f.get("question_text"):
            action_field["question_text"] = f.get("question_text")
        if f.get("alt"):
            action_field["alt"] = f.get("alt")
        if f.get("text"):
            action_field["text"] = f.get("text")

        if interaction in {"select", "check"}:
            options = []
            for opt in (f.get("options") or []):
                if not isinstance(opt, dict):
                    continue
                opt_item = {
                    "value": opt.get("value", ""),
                    "label": opt.get("label", "") or opt.get("alt", ""),
                }
                if interaction == "check":
                    opt_sel = opt.get("selector")
                    if isinstance(opt_sel, str) and opt_sel:
                        opt_item["selector"] = opt_sel
                    if opt.get("alt"):
                        opt_item["alt"] = opt.get("alt")
                    if opt.get("question_text"):
                        opt_item["question_text"] = opt.get("question_text")
                options.append(opt_item)
            action_field["options"] = options

        if interaction == "fill":
            input_type = str(f.get("inputType") or f.get("type") or "").lower()
            if input_type:
                action_field["input_type"] = input_type
            if f.get("min") is not None:
                action_field["min"] = f.get("min")
            if f.get("max") is not None:
                action_field["max"] = f.get("max")
            if f.get("step") is not None:
                action_field["step"] = f.get("step")
            if captcha_input_selector and selector == captcha_input_selector:
                action_field["kind"] = "captcha_input"
                if captcha_code_text:
                    action_field["expected_value"] = captcha_code_text

        if interaction == "set_range":
            if f.get("min") is not None:
                action_field["min"] = f.get("min")
            if f.get("max") is not None:
                action_field["max"] = f.get("max")
            if f.get("step") is not None:
                action_field["step"] = f.get("step")

        action_fields.append(action_field)

    selectors_map = schema.get("selectors") or {}
    for nav_key in ("next", "submit"):
        nav_selector = selectors_map.get(nav_key)
        if (
            isinstance(nav_selector, str)
            and nav_selector
            and nav_key not in seen_keys
        ):
            action_fields.append(
                {
                    "key": nav_key,
                    "interaction": "click",
                    "selector": nav_selector,
                    "label": nav_key,
                    "kind": "navigation_control",
                    "required": False,
                }
            )
            seen_keys.add(nav_key)

    for shape in (schema.get("shapes") or []):
        if not isinstance(shape, dict):
            continue
        shape_id = shape.get("id")
        if not isinstance(shape_id, str) or not shape_id:
            continue
        key = f"shape_{shape_id}"
        if key in seen_keys:
            continue
        action_fields.append(
            {
                "key": key,
                "interaction": "click",
                "selector": f'[data-shape-id="{shape_id}"]',
                "label": shape.get("kind") or "shape",
                "kind": "shape_option",
                "required": False,
            }
        )
        seen_keys.add(key)

    answerable_interactions = {"fill", "select", "check", "set_range"}
    required_answer_keys: List[str] = []
    interaction_counts: Dict[str, int] = {}
    required_count = 0
    answerable_count = 0
    navigation_count = 0
    for f in action_fields:
        interaction = str(f.get("interaction") or "")
        if interaction:
            interaction_counts[interaction] = interaction_counts.get(interaction, 0) + 1
        is_answerable = interaction in answerable_interactions
        is_required = bool(f.get("required") is True)
        if interaction == "click":
            navigation_count += 1
        if is_answerable:
            answerable_count += 1
            if is_required:
                required_count += 1
                key = f.get("key")
                if isinstance(key, str) and key:
                    required_answer_keys.append(key)

    return {
        "fields": action_fields,
        "meta": {
            "total_fields": len(action_fields),
            "answerable_count": answerable_count,
            "required_answerable_count": required_count,
            "navigation_count": navigation_count,
            "interaction_counts": interaction_counts,
            "required_answer_keys": required_answer_keys,
            "has_captcha": bool(captcha_info),
            "captcha": captcha_info if captcha_info else None,
        },
    }


def _build_image_option_map(action_space: Dict[str, Any]) -> Dict[str, Any]:
    """
    Build a compact per-step artifact for image-question auditing.
    The options array preserves DOM order (left->right in current UI grid).
    """
    result_items: List[Dict[str, Any]] = []
    for f in (action_space.get("fields") or []):
        if not isinstance(f, dict):
            continue
        if str(f.get("interaction") or "") != "check":
            continue
        key = str(f.get("key") or "")
        if not key.startswith("image_") and not key.startswith("attention_image"):
            continue
        opts_out: List[Dict[str, Any]] = []
        for idx, opt in enumerate(f.get("options") or []):
            if not isinstance(opt, dict):
                continue
            opts_out.append(
                {
                    "dom_order": idx,
                    "value": opt.get("value"),
                    "label": opt.get("label"),
                    "alt": opt.get("alt"),
                    "selector": opt.get("selector"),
                }
            )
        result_items.append(
            {
                "key": key,
                "question_text": str(f.get("question_text") or f.get("label") or ""),
                "options": opts_out,
            }
        )
    return {"image_items": result_items}


async def _read_ui_layout_trace(page: Any) -> Dict[str, Any]:
    try:
        value = await page.evaluate(
            """() => {
                try {
                    const t = window.__surveyLayoutTrace;
                    if (!t || typeof t !== "object") return null;
                    return t;
                } catch (_) {
                    return null;
                }
            }"""
        )
        if isinstance(value, dict):
            return value
        return {}
    except Exception:
        return {}


async def _is_checkable_selector(page: Any, selector: str) -> bool:
    try:
        return bool(
            await page.eval_on_selector(
                selector,
                "el => el.tagName.toLowerCase() === 'input' && ['radio','checkbox'].includes((el.getAttribute('type') || '').toLowerCase())",
            )
        )
    except Exception:
        return False


async def _log_page_marker(page: Any, logger: TraceLogger, step_idx: int, stage: str):
    try:
        marker = await page.evaluate(
            """() => {
                const title = document.title || "";
                const h = document.querySelector("h1, h2");
                let hasTextAnswers = null;
                let hasImageAnswers = null;
                try {
                    hasTextAnswers = Boolean(sessionStorage.getItem("survey_text_answers"));
                    hasImageAnswers = Boolean(sessionStorage.getItem("survey_image_answers"));
                } catch (_) {}
                return {
                    title,
                    heading: h ? (h.textContent || "").trim() : "",
                    has_text_answers_store: hasTextAnswers,
                    has_image_answers_store: hasImageAnswers
                };
            }"""
        )
    except Exception:
        marker = {
            "title": "",
            "heading": "",
            "has_text_answers_store": None,
            "has_image_answers_store": None,
        }
    logger.log(
        "page_marker",
        {
            "step_idx": step_idx,
            "stage": stage,
            "url": page.url,
            "title": marker.get("title", ""),
            "heading": marker.get("heading", ""),
            "has_text_answers_store": marker.get("has_text_answers_store"),
            "has_image_answers_store": marker.get("has_image_answers_store"),
        },
    )


def _get_ctx(config) -> "RunCtx":
    cfg = config or {}
    conf = cfg.get("configurable", {})
    ctx = conf.get("ctx")
    if ctx is None:
        raise RuntimeError("Missing ctx in LangGraph config. Pass config={'configurable': {'ctx': ctx}}")
    return ctx


def _detect_required_tag() -> str:
    """
    Infer required-enforcement mode from survey-site page toggles.
    Returns:
    - "RT" if both text+image toggles are true
    - "NRT" otherwise
    """
    root = Path(__file__).resolve().parent.parent
    text_page = root / "survey-site" / "app" / "survey" / "text" / "page.tsx"
    image_page = root / "survey-site" / "app" / "survey" / "image" / "page.tsx"
    pattern = re.compile(r"^\s*const\s+ENFORCE_REQUIRED_[A-Z_]+\s*=\s*(true|false)\s*;", re.MULTILINE)

    def _is_required_true(path: Path) -> bool:
        try:
            content = path.read_text(encoding="utf-8")
        except Exception:
            return False
        match = pattern.search(content)
        if not match:
            return False
        return match.group(1).lower() == "true"

    return "RT" if _is_required_true(text_page) and _is_required_true(image_page) else "NRT"


async def node_observe(state: AgentState, config) -> AgentState:
    ctx = _get_ctx(config)
    if state.get("done"):
        return state
    _emit_progress(ctx, "observe:start", state)

    step_idx = int(state.get("step_idx", 0)) + 1
    max_steps = int(state.get("max_steps", 50))
    prior_url = str(state.get("url", ""))
    current_url = ctx.page.url

    if "/survey/done" not in current_url and "/survey/thank-you" not in current_url:
        # 1) Wait for Next.js/SPA to finish initial "Loading..." shell (if present)
        await tool_wait_for_not_loading(ctx.page, ctx.logger, timeout_ms=20_000)

        # 2) Wait until the real form UI is present (any form element is enough)
        await tool_wait_for_any(
            ctx.page,
            ctx.logger,
            selectors=["input", "select", "textarea", "button", "form"],
            timeout_ms=20_000,
        )

    # 3) Now take evidence
    shot_path = ctx.out_dir / f"shot_{step_idx}.png"
    dom_path = ctx.out_dir / f"dom_{step_idx}.html"
    dom_html = await ctx.page.content()
    if SAVE_DOM_HTML_ARTIFACTS:
        dom_path.write_text(dom_html, encoding="utf-8")
        ctx.logger.log("dom_snapshot", {"path": str(dom_path)})
    else:
        dom_path = Path("")
    await tool_screenshot(ctx.page, ctx.logger, shot_path)
    await _log_page_marker(ctx.page, ctx.logger, step_idx, "observe")

    parsed = parse_survey_dom(dom_html)
    action_space = build_action_space(parsed)
    action_space_path = ctx.out_dir / f"action_space_{step_idx}.json"
    action_space_path.write_text(json.dumps(action_space, indent=2), encoding="utf-8")
    image_option_map = _build_image_option_map(action_space)
    if image_option_map.get("image_items"):
        image_option_map_path = ctx.out_dir / f"image_option_map_{step_idx}.json"
        image_option_map_path.write_text(json.dumps(image_option_map, indent=2), encoding="utf-8")
        ctx.logger.log(
            "image_option_map",
            {
                "step_idx": step_idx,
                "path": str(image_option_map_path),
                "item_count": len(image_option_map.get("image_items") or []),
            },
        )
    if "/survey/image" in current_url:
        ui_layout_trace = await _read_ui_layout_trace(ctx.page)
        if ui_layout_trace:
            ui_layout_trace_path = ctx.out_dir / f"ui_layout_trace_{step_idx}.json"
            ui_layout_trace_path.write_text(json.dumps(ui_layout_trace, indent=2), encoding="utf-8")
            # Keep a stable latest path for run-level evaluators.
            (ctx.out_dir / "ui_layout_trace.json").write_text(json.dumps(ui_layout_trace, indent=2), encoding="utf-8")
            ctx.logger.log(
                "ui_layout_trace",
                {
                    "step_idx": step_idx,
                    "path": str(ui_layout_trace_path),
                    "question_count": len((ui_layout_trace.get("questions") or [])),
                },
            )
    interaction_counts: Dict[str, int] = {}
    for f in (action_space.get("fields") or []):
        interaction = str(f.get("interaction") or "")
        if not interaction:
            continue
        interaction_counts[interaction] = interaction_counts.get(interaction, 0) + 1
    ctx.logger.log(
        "action_space",
        {
            "step_idx": step_idx,
            "path": str(action_space_path),
            "field_count": len(action_space.get("fields") or []),
            "interaction_counts": interaction_counts,
        },
    )
    current_url = ctx.page.url
    url_changed = bool(prior_url and prior_url != current_url)
    if url_changed:
        ctx.logger.log(
            "page_changed",
            {
                "old_url": prior_url,
                "new_url": current_url,
                "reset_plan_feedback": True,
            },
        )
    ctx.logger.log("observe_state", {"step_idx": step_idx, "url": current_url})
    _emit_progress(
        ctx,
        "observe:end",
        state,
        {
            "observed_step_idx": step_idx,
            "action_space_fields": len(action_space.get("fields") or []),
        },
    )

    done = bool(state.get("done", False))
    error = state.get("error")
    plan_feedback = [] if url_changed else list(state.get("plan_feedback") or [])
    empty_plan_streak = 0 if url_changed else int(state.get("empty_plan_streak", 0))
    if step_idx >= max_steps:
        done = True
        error = "max_steps_exceeded"

    return {
        **state,
        "url": current_url,
        "parsed": parsed,
        "action_space": action_space,
        "action_space_path": str(action_space_path),
        "dom_path": str(dom_path) if str(dom_path) else "",
        "screenshot_path": str(shot_path),
        "step_idx": step_idx,
        "max_steps": max_steps,
        "plan_feedback": plan_feedback,
        "empty_plan_streak": empty_plan_streak,
        "done": done,
        "error": error,
    }

async def node_plan(state: AgentState, config) -> AgentState:
    ctx = _get_ctx(config)
    _emit_progress(ctx, "plan:start", state)

    schema = state.get("parsed") or {}
    action_space = state.get("action_space") or {}
    ctx.logger.log(
        "plan_input",
        {
            "step_idx": state.get("step_idx", 0),
            "action_space_path": state.get("action_space_path", ""),
            "action_space_field_count": len(action_space.get("fields") or []),
        },
    )
    screenshot_path = state.get("screenshot_path")
    feedback = list(state.get("plan_feedback") or [])
    feedback = feedback[-MAX_FEEDBACK_MEMORY:]
    if feedback:
        ctx.logger.log("plan_feedback_used", {"count": len(feedback), "feedback": feedback})

    plan: List[Dict[str, Any]] = []
    last_error = ""
    for attempt in range(MAX_PLAN_RETRIES + 1):
        attempt_feedback = feedback[-MAX_FEEDBACK_MEMORY:]
        attempt_started = time.monotonic()
        _emit_progress(
            ctx,
            "plan:attempt",
            state,
            {
                "attempt": attempt + 1,
                "max_attempts": MAX_PLAN_RETRIES + 1,
                "feedback_count": len(attempt_feedback),
            },
        )
        try:
            plan = await ctx.brain.plan(
                schema=schema,
                action_space=action_space,
                screenshot_path=Path(screenshot_path) if screenshot_path else None,
                validation_feedback=attempt_feedback,
            )
            if attempt > 0:
                ctx.logger.log("plan_recovered", {"attempt": attempt + 1, "plan_size": len(plan)})
            _emit_progress(
                ctx,
                "plan:success",
                state,
                {
                    "attempt": attempt + 1,
                    "plan_size": len(plan),
                    "elapsed_s": round(time.monotonic() - attempt_started, 2),
                },
            )
            break
        except Exception as exc:
            last_error = str(exc)
            ctx.logger.log("plan_reject", {"attempt": attempt + 1, "error": last_error})
            _emit_progress(
                ctx,
                "plan:reject",
                state,
                {
                    "attempt": attempt + 1,
                    "elapsed_s": round(time.monotonic() - attempt_started, 2),
                    "error": last_error[:200],
                },
            )
            feedback.append(last_error)
            feedback = feedback[-MAX_FEEDBACK_MEMORY:]
    else:
        ctx.logger.log("plan_fallback", {"error": last_error or "unknown_planning_error"})
        plan = []

    empty_plan_streak = int(state.get("empty_plan_streak", 0))
    if plan:
        empty_plan_streak = 0
        feedback = []
    else:
        empty_plan_streak += 1
    if empty_plan_streak >= MAX_EMPTY_PLAN_STREAK:
        ctx.logger.log(
            "plan_stalled",
            {
                "empty_plan_streak": empty_plan_streak,
                "max_empty_plan_streak": MAX_EMPTY_PLAN_STREAK,
                "url": state.get("url", ""),
            },
        )
        ctx.logger.log("plan", {"steps": plan})
        return {
            **state,
            "plan": plan,
            "plan_feedback": feedback,
            "empty_plan_streak": empty_plan_streak,
            "done": True,
            "error": "empty_plan_streak_exceeded",
        }

    ctx.logger.log("plan", {"steps": plan})
    _emit_progress(ctx, "plan:end", state, {"plan_size": len(plan)})
    return {**state, "plan": plan, "plan_feedback": feedback, "empty_plan_streak": empty_plan_streak}


async def node_act(state: AgentState, config) -> AgentState:
    ctx = _get_ctx(config)
    _emit_progress(ctx, "act:start", state, {"plan_size": len(state.get("plan") or [])})
    current_url = ctx.page.url
    if "/survey/done" in current_url or "/survey/thank-you" in current_url:
        return {**state, "done": True, "url": current_url}

    plan = state.get("plan") or []
    schema = state.get("parsed") or {}
    selectors_map = schema.get("selectors", {})
    fields = schema.get("fields", [])
    field_by_selector = {
        f.get("selector"): f
        for f in fields
        if isinstance(f, dict) and isinstance(f.get("selector"), str)
    }
    check_option_by_selector: Dict[str, Dict[str, Any]] = {}
    for f in fields:
        if not isinstance(f, dict) or f.get("interaction") != "check":
            continue
        for opt in (f.get("options") or []):
            opt_selector = opt.get("selector")
            if not isinstance(opt_selector, str) or not opt_selector:
                continue
            check_option_by_selector[opt_selector] = {
                "parent_key": f.get("key"),
                "parent_label": f.get("label"),
                "option_label": opt.get("label"),
                "option_value": opt.get("value"),
                "field_kind": f.get("kind"),
            }

    actionable_fields = [
        f for f in fields if f.get("interaction") in {"fill", "select", "check", "set_range"}
    ]
    has_next_or_submit = bool(selectors_map.get("next") or selectors_map.get("submit"))
    if not actionable_fields and not has_next_or_submit:
        return {**state, "done": True, "url": current_url}

    for i, step in enumerate(plan):
        _emit_progress(
            ctx,
            "act:step:start",
            state,
            {"plan_index": i + 1, "plan_size": len(plan), "tool": step.get("tool")},
        )
        tool = step.get("tool")
        if tool == "done":
            return {**state, "done": True, "url": ctx.page.url}

        step_selector = step.get("selector")
        step_key = step.get("key")
        value = step.get("value")

        selector = ""
        if isinstance(step_selector, str) and step_selector.strip():
            selector = step_selector
        elif isinstance(step_key, str) and step_key.strip():
            selector = selectors_map.get(step_key, "")

        if not selector:
            raise RuntimeError(f"Step {i} missing valid selector/key: {step}")

        step_field = field_by_selector.get(selector, {}) or {}
        option_meta = check_option_by_selector.get(selector, {}) or {}
        ctx.logger.log(
            "exec_step",
            {
                "index": i,
                "tool": tool,
                "selector": selector,
                "value": value,
                "field_key": step_field.get("key") or option_meta.get("parent_key"),
                "field_label": step_field.get("label") or option_meta.get("parent_label"),
                "field_interaction": step_field.get("interaction") or ("check" if option_meta else None),
                "field_kind": step_field.get("kind") or option_meta.get("field_kind"),
                "question_text": step_field.get("question_text"),
                "alt": step_field.get("alt"),
                "option_label": option_meta.get("option_label"),
                "option_value": option_meta.get("option_value"),
            },
        )

        if tool == "fill":
            if await _is_checkable_selector(ctx.page, selector):
                await tool_check(ctx.page, ctx.logger, selector)
            else:
                await tool_fill(ctx.page, ctx.logger, selector, value)

        elif tool == "select":
            await tool_select(ctx.page, ctx.logger, selector, value)

        elif tool == "click":
            old_url = ctx.page.url
            await tool_click(ctx.page, ctx.logger, selector)
            selector_lower = selector.lower()
            if "next" in selector_lower or "submit" in selector_lower:
                await ctx.page.wait_for_timeout(300)
                try:
                    await ctx.page.wait_for_load_state("networkidle", timeout=5000)
                except Exception:
                    pass

                changed = await tool_wait_for_url_change(ctx.page, ctx.logger, old_url=old_url, timeout_ms=8000)
                await tool_wait_for_any(
                    ctx.page,
                    ctx.logger,
                    selectors=["input", "select", "textarea", "button", "form"],
                    timeout_ms=8000,
                )
                if not changed:
                    invalid_locator = ctx.page.locator(":invalid")
                    invalid_count = await invalid_locator.count()
                    for j in range(invalid_count):
                        invalid_info = await invalid_locator.nth(j).evaluate(
                            """el => {
                                const id = el.id || "";
                                const name = el.getAttribute("name") || "";
                                let selector = el.tagName.toLowerCase();
                                if (id) selector = "#" + id;
                                else if (name) selector = `${el.tagName.toLowerCase()}[name="${name}"]`;
                                return {
                                    selector,
                                    name,
                                    id,
                                    type: el.getAttribute("type") || "",
                                    validationMessage: el.validationMessage || ""
                                };
                            }"""
                        )
                        ctx.logger.log("invalid_field", invalid_info)

                    blocked_dom = ctx.out_dir / f"dom_validation_blocked_{i+1}.html"
                    blocked_shot = ctx.out_dir / f"shot_validation_blocked_{i+1}.png"
                    if SAVE_DOM_HTML_ARTIFACTS:
                        blocked_dom_html = await ctx.page.content()
                        blocked_dom.write_text(blocked_dom_html, encoding="utf-8")
                        ctx.logger.log("dom_snapshot", {"path": str(blocked_dom)})
                    await tool_screenshot(ctx.page, ctx.logger, blocked_shot)
                    ctx.logger.log(
                        "validation_blocked",
                        {
                            "step_index": i,
                            "selector": selector,
                            "url": ctx.page.url,
                            "invalid_count": invalid_count,
                        },
                    )
                else:
                    ctx.logger.log(
                        "navigation_detected",
                        {
                            "step_idx": state.get("step_idx", 0),
                            "old_url": old_url,
                            "new_url": ctx.page.url,
                        },
                    )
                if SAVE_DOM_HTML_ARTIFACTS:
                    act_dom = ctx.out_dir / f"dom_{state.get('step_idx', 0)}_act_{i+1}.html"
                    act_dom_html = await ctx.page.content()
                    act_dom.write_text(act_dom_html, encoding="utf-8")
                    ctx.logger.log("dom_snapshot", {"path": str(act_dom)})
                await tool_screenshot(ctx.page, ctx.logger, ctx.out_dir / f"shot_{state.get('step_idx', 0)}_act_{i+1}.png")
                await _log_page_marker(ctx.page, ctx.logger, int(state.get("step_idx", 0)), f"act_{i+1}")
                return {**state, "url": ctx.page.url, "last_exec_ts": time.monotonic()}

        elif tool == "check":
            await tool_check(ctx.page, ctx.logger, selector)

        elif tool == "set_range":
            try:
                numeric_value = int(float(value))
            except Exception:
                field = field_by_selector.get(selector, {})
                min_v = field.get("min")
                max_v = field.get("max")
                if min_v is not None and max_v is not None:
                    numeric_value = int((float(min_v) + float(max_v)) / 2)
                else:
                    numeric_value = 50
            await tool_set_range(ctx.page, ctx.logger, selector, numeric_value)
        else:
            raise RuntimeError(f"Unknown tool at step {i}: {tool}")

        state = {**state, "last_exec_ts": time.monotonic()}
        _emit_progress(
            ctx,
            "act:step:end",
            state,
            {"plan_index": i + 1, "plan_size": len(plan), "tool": tool},
        )

        # evidence after each step
        if SAVE_DOM_HTML_ARTIFACTS:
            act_dom = ctx.out_dir / f"dom_{state.get('step_idx', 0)}_act_{i+1}.html"
            act_dom_html = await ctx.page.content()
            act_dom.write_text(act_dom_html, encoding="utf-8")
            ctx.logger.log("dom_snapshot", {"path": str(act_dom)})
        await tool_screenshot(ctx.page, ctx.logger, ctx.out_dir / f"shot_{state.get('step_idx', 0)}_act_{i+1}.png")
        await _log_page_marker(ctx.page, ctx.logger, int(state.get("step_idx", 0)), f"act_{i+1}")

    return {**state, "url": ctx.page.url}


def build_graph():
    g = StateGraph(AgentState)
    g.add_node("observe", node_observe)
    g.add_node("plan", node_plan)
    g.add_node("act", node_act)

    def _after_observe(state: AgentState):
        if state.get("done"):
            return END
        if int(state.get("step_idx", 0)) >= int(state.get("max_steps", 50)):
            return END
        return "plan"

    g.set_entry_point("observe")
    g.add_conditional_edges("observe", _after_observe, {"plan": "plan", END: END})
    g.add_edge("plan", "act")
    g.add_edge("act", "observe")
    return g.compile()


def _build_brain() -> LLMVLMBasedBrain:
    stack = load_model_stack()
    return LLMVLMBasedBrain(config=stack)


async def main(headless: bool = False) -> Path:
    brain = _build_brain()
    prompt_behavior_mode = getattr(brain, "prompt_behavior_mode", "unknown")
    required_tag = _detect_required_tag()
    model_name = get_model_name_for_path()

    run_parent = Path("runs") / SURVEY_VERSION / model_name / prompt_behavior_mode
    run_base = f"run_{datetime.now().strftime('%H%M')}_{required_tag}"
    out_dir = run_parent / run_base
    if out_dir.exists():
        suffix = 2
        while (run_parent / f"{run_base}_{suffix}").exists():
            suffix += 1
        out_dir = run_parent / f"{run_base}_{suffix}"
    out_dir.mkdir(parents=True, exist_ok=True)

    async with async_playwright() as p:
        browser = await p.chromium.launch(headless=headless)
        context = await browser.new_context()
        page = await context.new_page()

        logger = TraceLogger(out_dir)
        if hasattr(brain, "debug_hook"):
            brain.debug_hook = logger.log
        run_error: BaseException | None = None
        try:
            logger.log(
                "run_context",
                {
                    "survey_version": SURVEY_VERSION,
                    "model_name": model_name,
                    "prompt_behavior_mode": prompt_behavior_mode,
                    "planner_mode": getattr(brain, "mode", ""),
                    "required_tag": required_tag,
                    "target": TARGET,
                    "headless": headless,
                },
            )
            await tool_goto(page, logger, TARGET)

            graph = build_graph()
            ctx = RunCtx(page=page, logger=logger, out_dir=out_dir, brain=brain)

            # Run
            await graph.ainvoke(
                {"url": TARGET, "step_idx": 0, "max_steps": 50, "done": False},
                config={"configurable": {"ctx": ctx}},
            )
        except BaseException as exc:
            run_error = exc
            logger.log("run_error", {"error_type": type(exc).__name__, "error": str(exc)})
        finally:
            logger.save()
            try:
                await context.close()
            except Exception:
                pass
            try:
                await browser.close()
            except Exception:
                pass

        if run_error is not None:
            raise run_error

    resolved = out_dir.resolve()
    print(f"Saved run artifacts to: {resolved}")
    return resolved


if __name__ == "__main__":
    asyncio.run(main(headless=False))
