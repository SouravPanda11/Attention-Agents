import asyncio
import re
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, TypedDict

from langgraph.graph import StateGraph, END
from playwright.async_api import async_playwright
from lxml import html as lxml_html

from brain import LLMVLMBasedBrain
from model_stack import load_model_stack

from tools import (
    TraceLogger,
    tool_click,
    tool_dom_snapshot,
    tool_fill,
    tool_goto,
    tool_screenshot,
    tool_set_range,
    tool_select,
    tool_wait_for_any,
    tool_wait_for_not_loading,
    tool_wait_for_url_change,
    tool_check,
)

TARGET = "http://localhost:3000/survey"


class AgentState(TypedDict, total=False):
    url: str
    dom_path: str
    screenshot_path: str
    parsed: Dict[str, Any]
    plan: List[Dict[str, Any]]
    step_idx: int
    max_steps: int
    done: bool
    error: str


@dataclass
class RunCtx:
    page: Any
    logger: TraceLogger
    out_dir: Path
    brain: Any


def parse_survey_dom(dom_html: str) -> Dict[str, Any]:
    """
    Extract generic form schema for LLM planning:
    - available selectors for fill/select/click
    - field metadata (type/label/options)
    - shape targets for visual attention checks
    """
    tree = lxml_html.fromstring(dom_html)
    root_tree = tree.getroottree()

    def selector_for(el) -> str | None:
        element_id = el.get("id")
        if element_id:
            return f"#{element_id}"

        name = el.get("name")
        if name:
            return f'{el.tag}[name="{name}"]'

        data_testid = el.get("data-testid")
        if data_testid:
            return f'{el.tag}[data-testid="{data_testid}"]'

        if el.tag == "button":
            text = " ".join(el.itertext()).strip()
            if text:
                safe_text = text.replace('"', '\\"')
                return f'button:has-text("{safe_text}")'
            return "button"

        # Fallback for unlabeled controls generated by React.
        return f"xpath={root_tree.getpath(el)}"

    def selector_for_any(el) -> str:
        element_id = el.get("id")
        if element_id:
            return f"#{element_id}"
        data_testid = el.get("data-testid")
        if data_testid:
            return f'{el.tag}[data-testid="{data_testid}"]'
        aria_label = el.get("aria-label")
        if aria_label:
            safe_label = aria_label.replace('"', '\\"')
            return f'{el.tag}[aria-label="{safe_label}"]'
        return f"xpath={root_tree.getpath(el)}"

    def label_for(el) -> str:
        element_id = el.get("id")
        if element_id:
            candidates = tree.cssselect(f'label[for="{element_id}"]')
            if candidates:
                return " ".join(candidates[0].itertext()).strip()

        parent = el.getparent()
        if parent is not None and parent.tag == "label":
            return " ".join(parent.itertext()).strip()

        return ""

    schema = {
        "selectors": {},
        "fields": [],
        "shapes": [],
        "captcha": None,
    }

    field_index = 0
    grouped_radios: Dict[str, Dict[str, Any]] = {}
    radios = tree.cssselect('input[type="radio"]')
    radios_by_name: Dict[str, List[Any]] = {}
    for radio in radios:
        radio_name = radio.get("name")
        if radio_name:
            radios_by_name.setdefault(radio_name, []).append(radio)

    for name, group in radios_by_name.items():
        group_selector = f'input[type="radio"][name="{name}"]'
        grouped_radios[name] = {
            "key": name,
            "selector": group_selector,
            "tag": "input",
            "type": "radio",
            "label": label_for(group[0]),
            "interaction": "check",
            "options": [],
        }
        schema["selectors"][name] = group_selector

        for idx, el in enumerate(group):
            element_id = el.get("id")
            if element_id:
                option_selector = f"#{element_id}"
            else:
                option_selector = f'input[type="radio"][name="{name}"] >> nth={idx}'

            grouped_radios[name]["options"].append(
                {
                    "id": element_id,
                    "value": el.get("value") or "on",
                    "label": label_for(el),
                    "selector": option_selector,
                }
            )
            field_index += 1

    schema["fields"].extend(grouped_radios.values())

    for el in tree.cssselect("input, textarea, select, button"):
        if el.tag == "input" and (el.get("type") or "").lower() in {"radio"}:
            continue

        selector = selector_for(el)
        if not selector:
            continue

        key = el.get("id") or el.get("name") or f"field_{field_index}"
        field_index += 1
        schema["selectors"][key] = selector

        interaction = "fill"
        input_type = (el.get("type") or "").lower() if el.tag == "input" else ""
        if el.tag == "input" and input_type == "range":
            interaction = "set_range"
        elif el.tag == "input" and input_type == "checkbox":
            interaction = "check"
        if el.tag == "select":
            interaction = "select"
        elif el.tag == "button":
            interaction = "click"

        field = {
            "key": key,
            "selector": selector,
            "tag": el.tag,
            "type": el.get("type") if el.tag == "input" else None,
            "inputType": el.get("type") if el.tag == "input" else None,
            "name": el.get("name"),
            "id": el.get("id"),
            "required": bool(el.get("required") is not None),
            "label": label_for(el),
            "placeholder": el.get("placeholder"),
            "text": " ".join(el.itertext()).strip() if el.tag == "button" else "",
            "interaction": interaction,
        }

        if el.tag == "select":
            field["options"] = [
                {
                    "value": opt.get("value", ""),
                    "label": " ".join(opt.itertext()).strip(),
                }
                for opt in el.cssselect("option")
            ]

        if interaction == "set_range":
            min_v = float(el.get("min") or 0)
            max_v = float(el.get("max") or 100)
            step_v = float(el.get("step") or 1)
            default_v = float(el.get("value") or min_v)
            field["min"] = min_v
            field["max"] = max_v
            field["step"] = step_v
            field["default"] = default_v

        if el.tag == "input" and input_type == "number":
            field["min"] = float(el.get("min")) if el.get("min") is not None else None
            field["max"] = float(el.get("max")) if el.get("max") is not None else None
            field["step"] = float(el.get("step")) if el.get("step") is not None else None

        if interaction == "check" and (el.get("type") or "").lower() == "checkbox":
            checkbox_value = el.get("value") or "on"
            checkbox_id = el.get("id")
            option_selector = f"#{checkbox_id}" if checkbox_id else selector
            field["options"] = [
                {
                    "id": checkbox_id,
                    "value": checkbox_value,
                    "label": label_for(el),
                    "selector": option_selector,
                }
            ]

        schema["fields"].append(field)
        if el.tag == "button":
            button_text = " ".join(el.itertext()).strip().lower()
            if "next" in button_text:
                schema["selectors"]["next"] = selector if selector != "button" else 'button:has-text("Next")'
            if "submit" in button_text:
                schema["selectors"]["submit"] = selector

    def question_text_for(el) -> str:
        prev_nodes = el.xpath(
            "preceding::*[(self::h1 or self::h2 or self::h3 or self::label or self::div) and normalize-space()]"
        )
        for node in reversed(prev_nodes):
            text = " ".join(node.itertext()).strip()
            if not text:
                continue
            lowered = text.lower()
            if re.match(r"^\d+\)", text) or "which image" in lowered or "select the" in lowered:
                return text
        if prev_nodes:
            return " ".join(prev_nodes[-1].itertext()).strip()
        return ""

    # Parse likely image answer options on /survey/image
    image_option_idx = 0
    for el in tree.cssselect("div, figure, a, button, label, img, [role='button'], div[role], div[onclick]"):
        img = el if el.tag == "img" else (el.cssselect("img")[0] if el.cssselect("img") else None)
        if img is None:
            continue

        style_text = (el.get("style") or "").lower()
        has_pointer = "cursor: pointer" in style_text or "cursor:pointer" in style_text
        has_hint_attr = bool(el.get("data-testid") or el.get("aria-label") or el.get("id"))
        if not (has_pointer or has_hint_attr or el.tag == "img"):
            continue

        clickable = el if el.tag != "img" else (el.getparent() if el.getparent() is not None else el)
        selector = selector_for_any(clickable)
        key = f"image_option_{image_option_idx}"
        image_option_idx += 1

        src = img.get("src")
        alt = img.get("alt") or ""
        qtext = question_text_for(clickable)

        field = {
            "key": key,
            "selector": selector,
            "tag": clickable.tag,
            "interaction": "click",
            "kind": "image_option",
            "question_text": qtext,
            "alt": alt,
            "src": src,
            "name": clickable.get("name"),
            "id": clickable.get("id"),
            "required": False,
        }
        schema["fields"].append(field)
        schema["selectors"][key] = selector

    # Detect captcha code text near captcha input.
    captcha_inputs = tree.xpath(
        "//input[contains(translate(@placeholder,'ABCDEFGHIJKLMNOPQRSTUVWXYZ','abcdefghijklmnopqrstuvwxyz'),'code') "
        "or contains(translate(@aria-label,'ABCDEFGHIJKLMNOPQRSTUVWXYZ','abcdefghijklmnopqrstuvwxyz'),'code')]"
    )
    if captcha_inputs:
        cap_input = captcha_inputs[0]
        input_selector = selector_for_any(cap_input)
        token_regex = re.compile(r"\b(?=[A-Z0-9]{4,8}\b)(?=.*[A-Z])(?=.*\d)[A-Z0-9]{4,8}\b")
        code_text = None
        nearby = cap_input.xpath("preceding::*[(self::div or self::span or self::p) and normalize-space()]")
        for node in reversed(nearby[-30:]):
            text = " ".join(node.itertext()).strip()
            token = token_regex.search(text.upper())
            if token:
                code_text = token.group(0)
                break
        if code_text:
            schema["captcha"] = {"code_text": code_text, "input_selector": input_selector}
            schema["selectors"]["captcha_input"] = input_selector

    # Shapes have data-shape-id and data-shape-kind
    for el in tree.cssselect("[data-shape-id][data-shape-kind]"):
        schema["shapes"].append(
            {
                "id": el.get("data-shape-id"),
                "kind": el.get("data-shape-kind"),
                # We can later add bbox extraction via Playwright if needed
            }
        )

    return schema


async def _is_checkable_selector(page: Any, selector: str) -> bool:
    try:
        return bool(
            await page.eval_on_selector(
                selector,
                "el => el.tagName.toLowerCase() === 'input' && ['radio','checkbox'].includes((el.getAttribute('type') || '').toLowerCase())",
            )
        )
    except Exception:
        return False


async def _log_page_marker(page: Any, logger: TraceLogger, step_idx: int, stage: str):
    try:
        marker = await page.evaluate(
            """() => {
                const title = document.title || "";
                const h = document.querySelector("h1, h2");
                return { title, heading: h ? (h.textContent || "").trim() : "" };
            }"""
        )
    except Exception:
        marker = {"title": "", "heading": ""}
    logger.log(
        "page_marker",
        {
            "step_idx": step_idx,
            "stage": stage,
            "url": page.url,
            "title": marker.get("title", ""),
            "heading": marker.get("heading", ""),
        },
    )


def _normalize_question_key(text: str) -> str:
    return re.sub(r"\s+", " ", (text or "").strip()).lower()


def _question_sort_key(text: str) -> tuple:
    m = re.match(r"^(\d+)\)", (text or "").strip())
    return (int(m.group(1)) if m else 10_000, text or "")


def _enforce_plan_guardrails(plan: List[Dict[str, Any]], schema: Dict[str, Any], current_url: str) -> List[Dict[str, Any]]:
    fields = schema.get("fields", [])
    selectors = schema.get("selectors", {})
    field_by_selector = {
        f.get("selector"): f
        for f in fields
        if isinstance(f, dict) and isinstance(f.get("selector"), str)
    }

    # Deterministic image-page plan: one click per question + captcha + next.
    if "/survey/image" in current_url:
        image_fields = [
            f for f in fields if f.get("interaction") == "click" and f.get("kind") == "image_option" and f.get("selector")
        ]
        grouped: Dict[str, List[Dict[str, Any]]] = {}
        for f in image_fields:
            q = _normalize_question_key(f.get("question_text") or f.get("alt") or "")
            grouped.setdefault(q, []).append(f)

        deterministic: List[Dict[str, Any]] = []
        ordered_groups = sorted(grouped.items(), key=lambda kv: _question_sort_key(kv[1][0].get("question_text", "")))
        for _, options in ordered_groups:
            options_sorted = sorted(options, key=lambda o: (o.get("selector") or ""))
            deterministic.append({"tool": "click", "selector": options_sorted[0]["selector"]})

        captcha = schema.get("captcha") or {}
        code = captcha.get("code_text")
        cap_selector = captcha.get("input_selector")
        if code and cap_selector:
            deterministic.append({"tool": "fill", "selector": cap_selector, "value": code})

        next_selector = selectors.get("next") or selectors.get("submit") or 'button:has-text("Next")'
        deterministic.append({"tool": "click", "selector": next_selector})
        return deterministic

    fixed: List[Dict[str, Any]] = []
    for step in plan:
        if not isinstance(step, dict):
            continue
        tool = step.get("tool")
        if tool == "check":
            selector = str(step.get("selector", ""))
            # Avoid default-first radio option where nth selectors are used.
            if ">> nth=0" in selector:
                alt_selector = selector.replace(">> nth=0", ">> nth=1")
                fixed.append({**step, "selector": alt_selector})
            else:
                fixed.append(step)
            continue

        if tool == "set_range":
            selector = step.get("selector")
            field = field_by_selector.get(selector, {})
            min_v = field.get("min")
            max_v = field.get("max")
            if min_v is not None and max_v is not None:
                mid = int((float(min_v) + float(max_v)) / 2)
                fixed.append({**step, "value": mid})
            else:
                fixed.append(step)
            continue

        if tool != "fill":
            fixed.append(step)
            continue

        selector = step.get("selector")
        field = field_by_selector.get(selector, {})
        placeholder = (field.get("placeholder") or "").strip().lower()
        input_type = (field.get("inputType") or field.get("type") or "").lower()
        value = str(step.get("value", ""))

        if placeholder and value.strip().lower() == placeholder:
            if input_type == "number":
                min_v = field.get("min")
                max_v = field.get("max")
                if min_v is not None and max_v is not None:
                    value = str(int((float(min_v) + float(max_v)) / 2))
                elif min_v is not None:
                    value = str(int(float(min_v)))
                else:
                    value = "25"
            else:
                value = "Test response"
            fixed.append({**step, "value": value})
        else:
            fixed.append(step)

    if fixed:
        return fixed

    # Deterministic fallback from schema when model output is empty/invalid.
    baseline: List[Dict[str, Any]] = []
    for field in fields:
        interaction = field.get("interaction")
        selector = field.get("selector")
        if not selector:
            continue

        if interaction == "fill":
            input_type = (field.get("inputType") or field.get("type") or "").lower()
            if input_type == "number":
                min_v = field.get("min")
                max_v = field.get("max")
                if min_v is not None and max_v is not None:
                    val = str(int((float(min_v) + float(max_v)) / 2))
                elif min_v is not None:
                    val = str(int(float(min_v)))
                else:
                    val = "25"
            else:
                val = "Test response"
            baseline.append({"tool": "fill", "selector": selector, "value": val})
        elif interaction == "select":
            options = field.get("options") or []
            valid = [o for o in options if o.get("value") and "select" not in (o.get("label") or "").strip().lower()]
            if valid:
                baseline.append({"tool": "select", "selector": selector, "value": valid[0]["value"]})
        elif interaction == "set_range":
            min_v = field.get("min")
            max_v = field.get("max")
            val = int((float(min_v) + float(max_v)) / 2) if min_v is not None and max_v is not None else 50
            baseline.append({"tool": "set_range", "selector": selector, "value": val})
        elif interaction == "check":
            options = field.get("options") or []
            if options:
                chosen = options[1] if len(options) > 1 else options[0]
                if chosen.get("selector"):
                    baseline.append({"tool": "check", "selector": chosen["selector"]})

    next_selector = selectors.get("next") or selectors.get("submit")
    if next_selector:
        baseline.append({"tool": "click", "selector": next_selector})

    return baseline


def _get_ctx(config) -> "RunCtx":
    cfg = config or {}
    conf = cfg.get("configurable", {})
    ctx = conf.get("ctx")
    if ctx is None:
        raise RuntimeError("Missing ctx in LangGraph config. Pass config={'configurable': {'ctx': ctx}}")
    return ctx


async def node_observe(state: AgentState, config) -> AgentState:
    ctx = _get_ctx(config)
    if state.get("done"):
        return state

    step_idx = int(state.get("step_idx", 0)) + 1
    max_steps = int(state.get("max_steps", 50))
    current_url = ctx.page.url

    if "/survey/done" not in current_url and "/survey/thank-you" not in current_url:
        # 1) Wait for Next.js/SPA to finish initial "Loading..." shell (if present)
        await tool_wait_for_not_loading(ctx.page, ctx.logger, timeout_ms=20_000)

        # 2) Wait until the real form UI is present (any form element is enough)
        await tool_wait_for_any(
            ctx.page,
            ctx.logger,
            selectors=["input", "select", "textarea", "button", "form"],
            timeout_ms=20_000,
        )

    # 3) Now take evidence
    dom_path = ctx.out_dir / f"dom_{step_idx}.html"
    shot_path = ctx.out_dir / f"shot_{step_idx}.png"
    await tool_dom_snapshot(ctx.page, ctx.logger, dom_path)
    await tool_screenshot(ctx.page, ctx.logger, shot_path)
    await _log_page_marker(ctx.page, ctx.logger, step_idx, "observe")

    dom_html = dom_path.read_text(encoding="utf-8")
    parsed = parse_survey_dom(dom_html)
    current_url = ctx.page.url
    ctx.logger.log("observe_state", {"step_idx": step_idx, "url": current_url})

    done = bool(state.get("done", False))
    error = state.get("error")
    if step_idx >= max_steps:
        done = True
        error = "max_steps_exceeded"

    return {
        **state,
        "url": current_url,
        "parsed": parsed,
        "dom_path": str(dom_path),
        "screenshot_path": str(shot_path),
        "step_idx": step_idx,
        "max_steps": max_steps,
        "done": done,
        "error": error,
    }

async def node_plan(state: AgentState, config) -> AgentState:
    ctx = _get_ctx(config)

    schema = state.get("parsed") or {}
    screenshot_path = state.get("screenshot_path")
    try:
        plan = await ctx.brain.plan(schema, Path(screenshot_path) if screenshot_path else None)
    except Exception as exc:
        ctx.logger.log("plan_fallback", {"error": str(exc)})
        plan = []
    plan = _enforce_plan_guardrails(plan, schema, state.get("url") or "")

    ctx.logger.log("plan", {"steps": plan})
    return {**state, "plan": plan}


async def node_act(state: AgentState, config) -> AgentState:
    ctx = _get_ctx(config)
    current_url = ctx.page.url
    if "/survey/done" in current_url or "/survey/thank-you" in current_url:
        return {**state, "done": True, "url": current_url}

    plan = state.get("plan") or []
    schema = state.get("parsed") or {}
    selectors_map = schema.get("selectors", {})
    fields = schema.get("fields", [])
    field_by_selector = {
        f.get("selector"): f
        for f in fields
        if isinstance(f, dict) and isinstance(f.get("selector"), str)
    }

    actionable_fields = [
        f for f in fields if f.get("interaction") in {"fill", "select", "check", "set_range"}
    ]
    has_next_or_submit = bool(selectors_map.get("next") or selectors_map.get("submit"))
    if not actionable_fields and not has_next_or_submit:
        return {**state, "done": True, "url": current_url}

    for i, step in enumerate(plan):
        tool = step.get("tool")
        if tool == "done":
            return {**state, "done": True, "url": ctx.page.url}

        step_selector = step.get("selector")
        step_key = step.get("key")
        value = step.get("value")

        selector = ""
        if isinstance(step_selector, str) and step_selector.strip():
            selector = step_selector
        elif isinstance(step_key, str) and step_key.strip():
            selector = selectors_map.get(step_key, "")

        if not selector:
            raise RuntimeError(f"Step {i} missing valid selector/key: {step}")

        ctx.logger.log(
            "exec_step",
            {
                "index": i,
                "tool": tool,
                "selector": selector,
                "value": value,
            },
        )

        if tool == "fill":
            if await _is_checkable_selector(ctx.page, selector):
                await tool_check(ctx.page, ctx.logger, selector)
            else:
                await tool_fill(ctx.page, ctx.logger, selector, value)

        elif tool == "select":
            await tool_select(ctx.page, ctx.logger, selector, value)

        elif tool == "click":
            old_url = ctx.page.url
            await tool_click(ctx.page, ctx.logger, selector)
            selector_lower = selector.lower()
            if "next" in selector_lower or "submit" in selector_lower:
                await ctx.page.wait_for_timeout(300)
                try:
                    await ctx.page.wait_for_load_state("networkidle", timeout=5000)
                except Exception:
                    pass

                changed = await tool_wait_for_url_change(ctx.page, ctx.logger, old_url=old_url, timeout_ms=8000)
                await tool_wait_for_any(
                    ctx.page,
                    ctx.logger,
                    selectors=["input", "select", "textarea", "button", "form"],
                    timeout_ms=8000,
                )
                if not changed:
                    invalid_locator = ctx.page.locator(":invalid")
                    invalid_count = await invalid_locator.count()
                    for j in range(invalid_count):
                        invalid_info = await invalid_locator.nth(j).evaluate(
                            """el => {
                                const id = el.id || "";
                                const name = el.getAttribute("name") || "";
                                let selector = el.tagName.toLowerCase();
                                if (id) selector = "#" + id;
                                else if (name) selector = `${el.tagName.toLowerCase()}[name="${name}"]`;
                                return {
                                    selector,
                                    name,
                                    id,
                                    type: el.getAttribute("type") || "",
                                    validationMessage: el.validationMessage || ""
                                };
                            }"""
                        )
                        ctx.logger.log("invalid_field", invalid_info)

                    blocked_dom = ctx.out_dir / f"dom_validation_blocked_{i+1}.html"
                    blocked_shot = ctx.out_dir / f"shot_validation_blocked_{i+1}.png"
                    await tool_dom_snapshot(ctx.page, ctx.logger, blocked_dom)
                    await tool_screenshot(ctx.page, ctx.logger, blocked_shot)
                    ctx.logger.log(
                        "validation_blocked",
                        {
                            "step_index": i,
                            "selector": selector,
                            "url": ctx.page.url,
                            "invalid_count": invalid_count,
                        },
                    )
                else:
                    ctx.logger.log(
                        "navigation_detected",
                        {
                            "step_idx": state.get("step_idx", 0),
                            "old_url": old_url,
                            "new_url": ctx.page.url,
                        },
                    )
                await tool_dom_snapshot(ctx.page, ctx.logger, ctx.out_dir / f"dom_{state.get('step_idx', 0)}_act_{i+1}.html")
                await tool_screenshot(ctx.page, ctx.logger, ctx.out_dir / f"shot_{state.get('step_idx', 0)}_act_{i+1}.png")
                await _log_page_marker(ctx.page, ctx.logger, int(state.get("step_idx", 0)), f"act_{i+1}")
                return {**state, "url": ctx.page.url}

        elif tool == "check":
            await tool_check(ctx.page, ctx.logger, selector)

        elif tool == "set_range":
            try:
                numeric_value = int(float(value))
            except Exception:
                field = field_by_selector.get(selector, {})
                min_v = field.get("min")
                max_v = field.get("max")
                if min_v is not None and max_v is not None:
                    numeric_value = int((float(min_v) + float(max_v)) / 2)
                else:
                    numeric_value = 50
            await tool_set_range(ctx.page, ctx.logger, selector, numeric_value)
        else:
            raise RuntimeError(f"Unknown tool at step {i}: {tool}")

        # evidence after each step
        await tool_dom_snapshot(ctx.page, ctx.logger, ctx.out_dir / f"dom_{state.get('step_idx', 0)}_act_{i+1}.html")
        await tool_screenshot(ctx.page, ctx.logger, ctx.out_dir / f"shot_{state.get('step_idx', 0)}_act_{i+1}.png")
        await _log_page_marker(ctx.page, ctx.logger, int(state.get("step_idx", 0)), f"act_{i+1}")

    return {**state, "url": ctx.page.url}


def build_graph():
    g = StateGraph(AgentState)
    g.add_node("observe", node_observe)
    g.add_node("plan", node_plan)
    g.add_node("act", node_act)

    def _after_observe(state: AgentState):
        if state.get("done"):
            return END
        if int(state.get("step_idx", 0)) >= int(state.get("max_steps", 50)):
            return END
        return "plan"

    g.set_entry_point("observe")
    g.add_conditional_edges("observe", _after_observe, {"plan": "plan", END: END})
    g.add_edge("plan", "act")
    g.add_edge("act", "observe")
    return g.compile()


def _build_brain() -> LLMVLMBasedBrain:
    stack = load_model_stack()
    return LLMVLMBasedBrain(config=stack)


async def main(headless: bool = False):
    run_base = f"run_{datetime.now().strftime('%H%M')}"
    out_dir = Path("runs") / run_base
    if out_dir.exists():
        suffix = 2
        while (Path("runs") / f"{run_base}_{suffix}").exists():
            suffix += 1
        out_dir = Path("runs") / f"{run_base}_{suffix}"
    out_dir.mkdir(parents=True, exist_ok=True)

    async with async_playwright() as p:
        browser = await p.chromium.launch(headless=headless)
        context = await browser.new_context()
        page = await context.new_page()

        logger = TraceLogger(out_dir)
        await tool_goto(page, logger, TARGET)

        graph = build_graph()
        ctx = RunCtx(page=page, logger=logger, out_dir=out_dir, brain=_build_brain())

        # Run
        await graph.ainvoke(
            {"url": TARGET, "step_idx": 0, "max_steps": 50, "done": False},
            config={"configurable": {"ctx": ctx}},
        )

        logger.save()
        await context.close()
        await browser.close()

    print(f"Saved run artifacts to: {out_dir.resolve()}")


if __name__ == "__main__":
    asyncio.run(main(headless=False))
